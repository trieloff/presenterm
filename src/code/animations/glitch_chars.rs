/// Get a glitched version of a character (visually similar but wrong)
pub(crate) fn get_glitched_char(original: char, seed: f32) -> Option<char> {
    // Map characters to their visually similar alternatives
    let alternatives: &[char] = match original {
        // Underscores and dashes
        '_' => &['-', '=', '—', '‾'],
        '-' => &['_', '=', '–', '―'],
        '=' => &['-', '_', '≡', '≈'],

        // Vertical bars and I variations
        '|' => &['I', 'l', '1', '¦', '∣'],
        'I' => &['l', '|', '1', 'i', '!'],
        'l' => &['I', '|', '1', 'i', '!'],
        'i' => &['l', 'I', '!', '¡', '1'],
        '!' => &['i', 'l', '1', 'I', '¦'],
        '1' => &['l', 'I', '|', 'i', '!'],

        // O variations
        'O' => &['0', 'o', 'Ο', 'Ο', 'Ø'],
        'o' => &['0', 'O', 'ο', '°', 'ø'],
        '0' => &['O', 'o', 'Ο', 'Ø', '∅'],

        // Slashes
        '/' => &['\\', '⁄', '∕', '╱'],
        '\\' => &['/', '⧵', '⧹', '╲'],

        // Parentheses and brackets
        '(' => &['[', '{', '⟨', 'c', '﹙'],
        ')' => &[']', '}', '⟩', '﹚'],
        '[' => &['(', '{', '⟦', '【'],
        ']' => &[')', '}', '⟧', '】'],
        '{' => &['[', '(', '⦃', '❴'],
        '}' => &[']', ')', '⦄', '❵'],

        // Quotes
        '\'' => &['`', '´', '\u{2018}', '′', '＇'], // ' → ` ´ ' ′ ＇
        '"' => &['\'', '\u{201C}', '\u{201D}', '″', '〃'], // " → ' " " ″ 〃
        '`' => &['\'', '\u{2018}', '′', '｀'], // ` → ' ' ′ ｀

        // Punctuation
        '.' => &[',', '·', '˙', '。', '․'],
        ',' => &['.', '\'', '‚', '､', '¸'],
        ':' => &[';', '∶', '᛬', '˸'],
        ';' => &[':', '‧', '⁏', '︔'],

        // Angle brackets
        '<' => &['‹', '≺', '⟨', '〈', '＜'],
        '>' => &['›', '≻', '⟩', '〉', '＞'],

        // Math/misc
        '+' => &['†', '✚', '➕', '＋'],
        '*' => &['✱', '⁎', '∗', '＊', '×'],
        '^' => &['ˆ', '︿', '∧', '＾'],
        '~' => &['˜', '∼', '～', '≈'],

        // Letters that look similar
        'A' => &['Α', 'А', 'Ａ', '∆'],
        'B' => &['Β', 'В', 'Ｂ', 'ß'],
        'C' => &['Ϲ', 'С', 'Ｃ', '⊂'],
        'E' => &['Ε', 'Е', 'Ｅ', '∃'],
        'H' => &['Η', 'Н', 'Ｈ', '卄'],
        'M' => &['Μ', 'М', 'Ｍ', 'Ⅿ'],
        'N' => &['Ν', 'Ｎ', 'И', 'ℕ'],
        'P' => &['Ρ', 'Р', 'Ｐ', 'ℙ'],
        'S' => &['Ѕ', 'Ｓ', '§', '∫'],
        'T' => &['Τ', 'Т', 'Ｔ', '┬'],
        'X' => &['Χ', 'Х', 'Ｘ', '✕'],
        'Y' => &['Υ', 'Ү', 'Ｙ', '¥'],
        'Z' => &['Ζ', 'Ｚ', 'ℤ', '≋'],

        // If no alternatives, return None
        _ => return None,
    };

    if alternatives.is_empty() {
        return None;
    }

    let index = ((seed.fract().abs() * alternatives.len() as f32) as usize) % alternatives.len();
    Some(alternatives[index])
}
